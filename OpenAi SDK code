import io
import re
from typing import Optional, Tuple

import pandas as pd
import streamlit as st

from agents import Agent, Runner  # openai-agents-python

import os
from dotenv import load_dotenv

load_dotenv()  # loads .env into environment variables

if not os.getenv("OPENAI_API_KEY"):
    st.error("OPENAI_API_KEY not found. Ensure it's set in .env or environment variables.")
    st.stop()
# -----------------------------
# Your prompts (as provided)
# -----------------------------
MAPPING_PROMPT = r"""
You are an Enterprise Architecture assistant.
Your task is to map Applications to Business Capabilities to support Application Portfolio Mapping (APM).

ENTERPRISE GLOSSARY
- A Capability represents what the business does or can do to achieve outcomes.
- A Capability is enabled or delivered by one or more Applications.
- An Application automates, supports, or enables one or more Capabilities.
- An Application has a lifecycle stage, a domain and an owner.

INPUT REQUIREMENTS
- Applications must be provided as an attached CSV or pasted CSV text.

INSTRUCTIONS
1. Identify which Applications directly enable or support each Capability.
2. Each application may map to one or more capabilities.
3. Only include mappings that are essential and relevant (avoid weak or indirect links).
4. Classify the domain and owner of the application.
5. Respond only in the required CSV format — no explanations or commentary.
6. Ask the user for user input
7. If the user pastes capabilities, then map those capabilities; otherwise, use the capabilities generated by the capability agent.

OUTPUT FORMAT
CSV

Example (one row per Application mapped to a Capability)
Capability name,Application ID,Application name,Domain,Owner,Lifecycle stage,Functional fit,Business value,Cost
Claims Information Management,A1,ClaimCore,Claim Information,Claims Ops,Active,High,High,120000
Claims Information Management,A10,ClaimArchive Pro,Claim Information,Claims Ops,Active,Medium,Medium,60000
Claims Information Management,A15,ClaimsLite,Claim Information,Claims Ops,Active,Low,Low,15000
Customer Information Management,A7,Customer Account Management,Customer Service & Operations,Customer Solutions,Active,High,High,80000

USER INPUT
Capabilities CSV: {{Capabilities}}
Applications CSV: {{Applications}}
""".strip()


ASSESSMENT_PROMPT = r"""
You are an Application Portfolio Assessment (APA) Assessment Agent.

OBJECTIVE
Using ONLY the user-provided mapped Application Capability dataset, produce an APA baseline that:
1) Measures redundancy (functional overlap) by Capability
2) Flags redundancy signals by Domain and Owner
3) Recommends rationalisation actions (Retain/Consolidate/Replace/Retire/Renovate) per application using ONLY provided fields (no assumptions)

ENTERPRISE GLOSSARY (triple form)
- Capability — represents — what the business does to achieve outcomes.
- Capability — is enabled or delivered by — one or more Applications.
- Application — automates/supports/enables — one or more Capabilities.
- Application rationalisation — decides — retain, replace, retire, consolidate, or renovate to reduce cost and improve efficiency.
- Redundancy — means — multiple Applications supporting the same Capability (functional overlap).
- Retain — means — keep applications that are critical/fit-for-purpose.
- Replace — means — substitute with a better alternative.
- Retire — means — remove applications no longer needed.
- Consolidate — means — merge duplicates into a single solution.
- Renovate — means — modernise or re-engineer an application.

INPUT (provided by user; one row per mapping)
Columns:
Capability name, Application ID, Application name, Domain, Owner, Lifecycle stage, Functional fit, Business value, Cost

RULES (STRICT)
1) Use ONLY the provided mappings. Do NOT invent missing data. If a field is missing, leave it blank.
2) Deduplicate exact-duplicate mappings (same Capability + same Application ID/name).
3) Redundancy by Capability:
   - Group rows by Capability name.
   - Applications = semicolon-separated list of unique Application names (or IDs if names missing).
   - App_Count = number of unique Applications for the Capability.
   - Redundancy_Flag = Yes if App_Count > 1 else No.
4) Domain redundancy signal (within the same Capability):
   - Domain_Redundancy_Flag = Yes if 2 plus applications under that Capability share the same Domain; else No.
5) Owner redundancy signal (within the same Capability):
   - Owner_Redundancy_Flag = Yes if 2 plus applications under that Capability share the same Owner; else No.

RATIONALISATION LOGIC (USE ONLY PROVIDED FIT/VALUE/COST/LIFECYCLE)
For each Capability with overlap (App_Count > 1), rank applications using:
- Prefer higher Business value
- Prefer higher Functional fit
- Prefer lower Cost (only as a tie-breaker)
- Prefer Active over non-active lifecycle stages (if provided)

Action assignment (per Capability group):
- Best-ranked application → Retain
- Other overlapping applications:
   - If Functional fit is Low OR Business value is Low → Replace (if an alternative exists in the same capability group) OR Consolidate
   - If Lifecycle indicates end-of-life/retired (if explicitly provided) → Retire
   - If Functional fit is Medium/High but needs improvement (only if indicated by provided data) → Renovate
   - Default for overlaps when unsure → Consolidate
IMPORTANT: Do not recommend Replace/Retire/Renovate unless supported by provided fields.

OUTPUT (CSV ONLY — NO COMMENTARY)
Use commas and semicolons exactly as shown:

Capability,Domain,Owner,Applications,App_Count,Redundancy_Flag,Domain_Redundancy_Flag,Owner_Redundancy_Flag,Recommended_Action
<Capability>,<Domain>,<Owner>,"<App 1>";"<App 2>",<number>,<Yes/No>,<Yes/No>,<Yes/No>,"<App1:Action>;<App2:Action>"
""".strip()


# -----------------------------
# Agents
# -----------------------------
mapping_agent = Agent(
    name="MappingAgent",
    instructions=MAPPING_PROMPT,
    model="gpt-4o",
)

assessment_agent = Agent(
    name="AssessmentAgent",
    instructions=ASSESSMENT_PROMPT,
    model="gpt-4o",
)


# -----------------------------
# Utilities
# -----------------------------
def is_retire_question(q: str) -> bool:
    return bool(re.search(r"\bretire|retired|decommission|sunset|eol|end[- ]of[- ]life\b", q.lower()))


def read_any(uploaded) -> pd.DataFrame:
    name = uploaded.name.lower()
    if name.endswith((".xlsx", ".xls")):
        return pd.read_excel(uploaded)
    return pd.read_csv(uploaded)


def coerce_csv_text_from_df(df: pd.DataFrame) -> str:
    return df.to_csv(index=False)


def try_parse_csv(text: str) -> Tuple[Optional[pd.DataFrame], Optional[str]]:
    """
    Parses CSV from model output.
    Returns (df, error). error is None if successful.
    """
    cleaned = text.strip()

    # Some models might wrap in ```csv ... ```
    cleaned = re.sub(r"^```csv\s*", "", cleaned, flags=re.IGNORECASE)
    cleaned = re.sub(r"^```\s*", "", cleaned, flags=re.IGNORECASE)
    cleaned = re.sub(r"\s*```$", "", cleaned)

    # Hard guard: must contain at least one comma (= likely CSV)
    if "," not in cleaned.splitlines()[0]:
        return None, "Output does not look like CSV (missing commas in header)."

    try:
        df = pd.read_csv(io.StringIO(cleaned))
        if df.empty:
            # Empty CSV can parse but be useless
            return df, None
        return df, None
    except Exception as e:
        return None, f"Failed to parse CSV: {e}"


def run_agent_csv(agent: Agent, payload: str, max_turns: int = 2) -> str:
    result = Runner.run_sync(
        starting_agent=agent,
        input=payload,
        max_turns=max_turns,
    )
    # RunResult has final_output (string) according to docs
    return result.final_output


# -----------------------------
# Streamlit UI
# -----------------------------
st.set_page_config(page_title="APM Mapping + APA Assessment (Agents SDK)", layout="wide")
st.title("APM Mapping + APA Assessment (OpenAI Agents SDK)")

st.sidebar.header("Inputs")

capabilities_text = st.sidebar.text_area(
    "Capabilities CSV (optional)",
    placeholder="Paste capability list CSV here (optional). If blank, mapping agent should use capability agent output (per your prompt).",
    height=140,
)

apps_upload = st.sidebar.file_uploader("Upload Applications file (CSV/XLSX)", type=["csv", "xlsx", "xls"])
apps_text = st.sidebar.text_area(
    "Or paste Applications CSV text",
    placeholder="Paste applications CSV here instead of uploading a file.",
    height=180,
)

st.sidebar.divider()
model_note = st.sidebar.caption("Model: gpt-5.1 (change in code if needed)")

# Session state
if "apps_df" not in st.session_state:
    st.session_state.apps_df = None
if "mapping_df" not in st.session_state:
    st.session_state.mapping_df = None
if "assessment_df" not in st.session_state:
    st.session_state.assessment_df = None
if "assessment_raw_csv" not in st.session_state:
    st.session_state.assessment_raw_csv = None
if "mapping_raw_csv" not in st.session_state:
    st.session_state.mapping_raw_csv = None


# Load applications dataframe if available
apps_df = None
if apps_upload is not None:
    apps_df = read_any(apps_upload)
elif apps_text.strip():
    apps_df = pd.read_csv(io.StringIO(apps_text.strip()))

st.session_state.apps_df = apps_df

colA, colB = st.columns([1, 1])

with colA:
    st.subheader("1) Applications")
    if apps_df is None:
        st.info("Upload an Applications CSV/XLSX or paste Applications CSV text to begin.")
    else:
        st.dataframe(apps_df, use_container_width=True, height=320)
        st.download_button(
            "Download Applications CSV (normalized)",
            data=coerce_csv_text_from_df(apps_df),
            file_name="applications_normalized.csv",
            mime="text/csv",
        )

with colB:
    st.subheader("2) Mapping Agent → App↔Capability mappings")
    st.caption("Produces: Capability name,Application ID,Application name,Domain,Owner,Lifecycle stage,Functional fit,Business value,Cost")

    run_map = st.button("Run Mapping Agent", type="primary", disabled=(apps_df is None))

    if run_map:
        apps_csv = coerce_csv_text_from_df(apps_df)
        payload = f"Capabilities CSV:\n{capabilities_text.strip()}\n\nApplications CSV:\n{apps_csv}"
        out = run_agent_csv(mapping_agent, payload, max_turns=2)
        st.session_state.mapping_raw_csv = out

        mapped_df, err = try_parse_csv(out)
        if err:
            st.error(err)
            st.code(out)
        else:
            st.session_state.mapping_df = mapped_df

    if st.session_state.mapping_df is not None:
        st.success("Mapping created.")
        st.dataframe(st.session_state.mapping_df, use_container_width=True, height=320)

        st.download_button(
            "Download Mapping CSV",
            data=st.session_state.mapping_df.to_csv(index=False),
            file_name="app_capability_mapping.csv",
            mime="text/csv",
        )
    elif st.session_state.mapping_raw_csv:
        st.warning("Mapping output received but not parsed. Showing raw:")
        st.code(st.session_state.mapping_raw_csv)


st.divider()

st.subheader("3) Assessment Agent → Baseline / Q&A")

question = st.text_input(
    "Ask a question (examples: 'Generate baseline', 'Which applications should be retired?')",
    value="Generate baseline",
)

run_assess = st.button("Run Assessment", disabled=(st.session_state.mapping_df is None))

if run_assess:
    mapped_csv = st.session_state.mapping_df.to_csv(index=False)
    payload = f"MAPPED_APPLICATION_CAPABILITY_DATASET:\n{mapped_csv}\n\nUSER_QUESTION:\n{question}"
    out = run_agent_csv(assessment_agent, payload, max_turns=2)
    st.session_state.assessment_raw_csv = out

    assessed_df, err = try_parse_csv(out)
    if err:
        st.error(err)
        st.code(out)
    else:
        st.session_state.assessment_df = assessed_df

if st.session_state.assessment_df is not None:
    mode = "Retire list" if is_retire_question(question) else "Baseline"
    st.success(f"Assessment complete ({mode}).")
    st.dataframe(st.session_state.assessment_df, use_container_width=True, height=360)

    filename = "apps_to_retire.csv" if is_retire_question(question) else "apa_baseline.csv"
    st.download_button(
        "Download Output CSV",
        data=st.session_state.assessment_df.to_csv(index=False),
        file_name=filename,
        mime="text/csv",
    )
elif st.session_state.assessment_raw_csv:
    st.warning("Assessment output received but not parsed. Showing raw:")
    st.code(st.session_state.assessment_raw_csv)
st.title("Architecture Copilot")
